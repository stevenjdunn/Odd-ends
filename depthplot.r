# Load packages
library(ggplot2)
library(reshape)
library(dplyr)
library(data.table)

# This code will generate a genome-wide coverage map compresed to 10-mers
# ggplot struggles to graph millions of data points (e.g. length of a prokaryotic genome)
# Plus the limitations of pixel density means any plot will not truly reflect all positions anyway.
# As input, I am using a file generated by a script I wrote to extract positional depth from the bam files produced by Snippy.
# You can acheive the same thing on a per sample basis with this unix one liner:
# samtools depth -a file | cut -f2,3 | sed 's/\t/,/g' > depth.txt
# Note the length of the genome with:
# tail -n1 snps.bam | cut -f1

# Load CSV produced from depthget.py:
data <- read.csv("~/Directory/output.csv")

# Get row means:
data.n <- data.frame(data$Position)
data.n$average <- rowMeans(data[2:34])

# Set names for easy syntax:
names(data.n) <- c("a","b")

# Compress genomic positions into 10-mers to allow graphing
# n.b to = ref. genome length in bp
# end = ref. genome length in bp - interval
coords <- data.frame(seq(from=1, to=1641471, by=10))
coords$end <- seq(from=10, to=1641481, by=10)
names(coords) <- c("c","d")

# Assign a constant value for graphing
coords$constant <- 1

# Set dataframes as datatables:
setDT(data.n)
setDT(coords)

# Sum values across the 10-mer coordinate ranges:
coords[, matched := data.n[coords, on=.(a >= c, a <= d), sum(b), by=.EACHI]$V1]


# Bin the matched values into factors according to summary info:
# n.b. as we are using k-mers, the true positional depth will be X/interval. This can be correctly displayed by using labels.
summary(coords$matched)
coords$bins <- cut(coords$matched, breaks=c(-Inf,0,1000,2000,4000,7000), labels=c("0","1-100","101-200","201-400","401-700"))


# Depth plot:
t <- ggplot(coords, aes(x=c, y=constant, fill=bins)) + geom_tile() +
  scale_fill_manual(values=c("#d0d1e6","#a6bddb","#67a9cf","#1c9099","#016c59")) +
  theme_void()
print(t)

# High coverage only
s <- ggplot(coords, aes(x=c, y=constant, fill=bins)) + geom_tile() +
  scale_fill_manual(values=c("#d0d1e6","#d0d1e6","#d0d1e6","#d0d1e6","#016c59")) +
  theme_void()
print(s)

# Save
ggsave(file="11168.eps", t, device="eps")
ggsave(file="11168_high.eps", s, device="eps")

# Note that the values passed to scale_fill_manual are derived from Colorbrewer, which is also included in ggplot. 
# I prefer to control the colour values manually, but you could use scale_fill_brewer.

# If you want to have axis on the graph, hash out theme_void() or replace it with another theme (e.g. theme_minimal)

# Repeated on a single isolate against a closer reference:
# This .csv was generated using the one-liner mentioned above.
data <- read.csv("~/Directory/depth.txt", header = FALSE)

# Compress to 10mer:
# As this is a de novo assembly, the length is different.
coords <- data.frame(seq(from=1, to=1525841, by=10))
coords$end <- seq(from=10, to=1525851, by=10)

# Change column names for easy syntax:
names(data) <- c("a","b")
names(coords) <- c("c","d")

# Set constant for graphing:
coords$constant <- 1

# Set datatables
setDT(coords)
setDT(data)

# Sum values across the 10-mer coordinate ranges:
coords[, matched := data[coords, on=.(a >= c, a <= d), sum(b), by=.EACHI]$V1]

# Bins
summary(coords$matched)
coords$bins <- cut(coords$matched, breaks=c(-Inf,0,1000,2000,4000,8000,Inf), labels=c("0","1-100","101-200","201-400","401-800","801-1500"))

# Plot
q <- ggplot(coords, aes(x=c, y=constant, fill=bins)) + geom_tile() +
  scale_fill_manual(values=c("#f0f9e8","#ccebc5","#a8ddb5","#7bccc4","#43a2ca","#0868ac")) +
  theme_void()
print(q)

# High cov only
h <- ggplot(coords, aes(x=c, y=constant, fill=bins)) + geom_tile() +
  scale_fill_manual(values=c("#f0f9e8","#f0f9e8","#f0f9e8","#f0f9e8","#43a2ca","#0868ac")) +
  theme_void()
print(h)

# Save
ggsave(file="stdrcov.eps", q, device="eps")
ggsave(file="highcov.eps", h, device="eps")
